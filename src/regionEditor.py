#!/usr/bin/env python
# -*- coding: iso-8859-15 -*-
# generated by wxGlade 0.6.5 (standalone edition) on Mon Feb 13 13:09:57 2012

import os
import sys
import collections
import time
import math
import numpy
import wx
import threading
import copy
import re
import winsound
import pyttsx
import lib.fileMethods as fileMethods
import lib.vicon as vicon
import lib.calibrate as calibrate
from lib.regionsPoints import Region, Point
import json
from lib.regions import prettierJSONEncoder

# begin wxGlade: extracode
# end wxGlade

class regionEditor(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: regionEditor.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.RegionEditor_menubar = wx.MenuBar()
        self.filemenu = wx.Menu()
        self.menuNew = wx.MenuItem(self.filemenu, wx.NewId(), "&New\tCTRL-N", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuNew)
        self.menuOpen = wx.MenuItem(self.filemenu, wx.NewId(), "&Open\tCTRL-O", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuOpen)
        self.menuSave = wx.MenuItem(self.filemenu, wx.NewId(), "&Save\tCTRL-S", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuSave)
        self.menuSaveAs = wx.MenuItem(self.filemenu, wx.NewId(), "Save &As", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuSaveAs)
        self.filemenu.AppendSeparator()
        self.menuExit = wx.MenuItem(self.filemenu, wx.NewId(), "&Quit\tCTRL-Q", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuExit)
        self.RegionEditor_menubar.Append(self.filemenu, "&File")
        self.menuEdit = wx.Menu()
        self.menuUndo = wx.MenuItem(self.menuEdit, wx.NewId(), "&Undo\tCTRL-Z", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuUndo)
        self.menuRedo = wx.MenuItem(self.menuEdit, wx.NewId(), "&Redo\tCTRL-Y", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuRedo)
        self.menuSelectAll = wx.MenuItem(self.menuEdit, wx.NewId(), "Select &All\tCTRL-A", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuSelectAll)
        self.menuEditRegion = wx.MenuItem(self.menuEdit, wx.NewId(), "&Edit Region\tCTRL-E", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuEditRegion)
        self.menuDeleteRegion = wx.MenuItem(self.menuEdit, wx.NewId(), "D&elete Region\tDEL", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuDeleteRegion)
        self.RegionEditor_menubar.Append(self.menuEdit, "&Edit")
        self.menuDrawing = wx.Menu()
        self.menuAutobound = wx.MenuItem(self.menuDrawing, wx.NewId(), "&Autoboundary", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuAutobound)
        self.menuRect = wx.MenuItem(self.menuDrawing, wx.NewId(), "&Rectangle\tR", "", wx.ITEM_CHECK)
        self.menuDrawing.AppendItem(self.menuRect)
        self.menuPoly = wx.MenuItem(self.menuDrawing, wx.NewId(), "&Polygon\tP", "", wx.ITEM_CHECK)
        self.menuDrawing.AppendItem(self.menuPoly)
        self.menuDrawing.AppendSeparator()
        self.menuAddPoint = wx.MenuItem(self.menuDrawing, wx.NewId(), "&Create Point\tC", "", wx.ITEM_CHECK)
        self.menuDrawing.AppendItem(self.menuAddPoint)
        self.menuRemPoint = wx.MenuItem(self.menuDrawing, wx.NewId(), "&Delete Point\tD", "", wx.ITEM_CHECK)
        self.menuDrawing.AppendItem(self.menuRemPoint)
        self.RegionEditor_menubar.Append(self.menuDrawing, "&Drawing")
        self.menuView = wx.Menu()
        self.menuMarkers = wx.MenuItem(self.menuView, wx.NewId(), "&Stream Markers", "", wx.ITEM_CHECK)
        self.menuView.AppendItem(self.menuMarkers)
        self.menuMarkersClear = wx.MenuItem(self.menuView, wx.NewId(), "Clear &Markers", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuMarkersClear)
        self.menuView.AppendSeparator()
        self.menuImageImport = wx.MenuItem(self.menuView, wx.NewId(), "&Import Background Image", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuImageImport)
        self.menuImageClear = wx.MenuItem(self.menuView, wx.NewId(), "Clear &Background Image", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuImageClear)
        self.menuView.AppendSeparator()
        self.menuFeedback = wx.MenuItem(self.menuView, wx.NewId(), "Audio &Feedback", "", wx.ITEM_CHECK)
        self.menuView.AppendItem(self.menuFeedback)
        self.menuView.AppendSeparator()
        self.menuCalibrate = wx.MenuItem(self.menuView, wx.NewId(), "&Calibrate", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuCalibrate)
        self.RegionEditor_menubar.Append(self.menuView, "&Tools")
        self.helpmenu = wx.Menu()
        self.menuAbout = wx.MenuItem(self.helpmenu, wx.NewId(), "&About", "", wx.ITEM_NORMAL)
        self.helpmenu.AppendItem(self.menuAbout)
        self.RegionEditor_menubar.Append(self.helpmenu, "&Help")
        self.SetMenuBar(self.RegionEditor_menubar)
        # Menu Bar end
        self.topbar = wx.Panel(self, -1)
        self.toggleVicon = wx.BitmapButton(self.topbar, -1, wx.NullBitmap)
        self.buttonImage = wx.BitmapButton(self.topbar, -1, wx.NullBitmap)
        self.toggleSquare = wx.BitmapButton(self.topbar, -1, wx.NullBitmap)
        self.togglePoly = wx.BitmapButton(self.topbar, -1, wx.NullBitmap)
        self.toggleDim = wx.BitmapButton(self.topbar, -1, wx.NullBitmap)
        self.buttonAutobound = wx.BitmapButton(self.topbar, -1, wx.NullBitmap)
        self.toggleFeedback = wx.BitmapButton(self.topbar, -1, wx.NullBitmap)
        self.buttonCal = wx.BitmapButton(self.topbar, -1, wx.NullBitmap)
        self.canvas = wx.Panel(self, -1, style=wx.SUNKEN_BORDER | wx.TAB_TRAVERSAL)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnMenuNew, self.menuNew)
        self.Bind(wx.EVT_MENU, self.OnMenuOpen, self.menuOpen)
        self.Bind(wx.EVT_MENU, self.OnMenuSave, self.menuSave)
        self.Bind(wx.EVT_MENU, self.OnMenuSaveAs, self.menuSaveAs)
        self.Bind(wx.EVT_MENU, self.OnMenuExit, self.menuExit)
        self.Bind(wx.EVT_MENU, self.OnMenuUndo, self.menuUndo)
        self.Bind(wx.EVT_MENU, self.OnMenuRedo, self.menuRedo)
        self.Bind(wx.EVT_MENU, self.OnMenuSelectAll, self.menuSelectAll)
        self.Bind(wx.EVT_MENU, self.OnMenuEditRegion, self.menuEditRegion)
        self.Bind(wx.EVT_MENU, self.OnMenuDeleteRegion, self.menuDeleteRegion)
        self.Bind(wx.EVT_MENU, self.OnMenuAutobound, self.menuAutobound)
        self.Bind(wx.EVT_MENU, self.OnMenuRect, self.menuRect)
        self.Bind(wx.EVT_MENU, self.OnMenuPoly, self.menuPoly)
        self.Bind(wx.EVT_MENU, self.OnMenuAddPoint, self.menuAddPoint)
        self.Bind(wx.EVT_MENU, self.OnMenuRemPoint, self.menuRemPoint)
        self.Bind(wx.EVT_MENU, self.OnMenuMarkers, self.menuMarkers)
        self.Bind(wx.EVT_MENU, self.OnMenuMarkersClear, self.menuMarkersClear)
        self.Bind(wx.EVT_MENU, self.OnMenuImageImport, self.menuImageImport)
        self.Bind(wx.EVT_MENU, self.OnMenuImageClear, self.menuImageClear)
        self.Bind(wx.EVT_MENU, self.OnMenuAbout, self.menuAbout)
        self.Bind(wx.EVT_BUTTON, self.OnToggleVicon, self.toggleVicon)
        self.Bind(wx.EVT_BUTTON, self.OnButtonImage, self.buttonImage)
        self.Bind(wx.EVT_BUTTON, self.OnToggleSquare, self.toggleSquare)
        self.Bind(wx.EVT_BUTTON, self.OnTogglePoly, self.togglePoly)
        self.Bind(wx.EVT_BUTTON, self.OnToggleDim, self.toggleDim)
        self.Bind(wx.EVT_BUTTON, self.OnButtonAutobound, self.buttonAutobound)
        self.Bind(wx.EVT_BUTTON, self.OnToggleFeedback, self.toggleFeedback)
        self.Bind(wx.EVT_BUTTON, self.OnButtonCal, self.buttonCal)
        # end wxGlade
        
        # Handle input that should be the regions file name to load
        if len(args) > 2 and isinstance(args[2], str):
            self.fileName = args[2]             # Full path to regions file
        else:
            self.fileName = ""
        
        # Bind mouse events
        self.canvas.Bind(wx.EVT_LEFT_DOWN, self.OnMouseLeftDown, self.canvas)
        self.canvas.Bind(wx.EVT_LEFT_UP, self.OnMouseLeftUp, self.canvas)
        self.canvas.Bind(wx.EVT_LEFT_DCLICK, self.OnMouseLeftDClick, self.canvas)
        self.canvas.Bind(wx.EVT_RIGHT_DOWN, self.OnMouseRightDown, self.canvas)
        self.canvas.Bind(wx.EVT_RIGHT_UP, self.OnMouseRightUp, self.canvas)
        self.canvas.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheel, self.canvas)
        self.canvas.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterWindow, self.canvas)
        self.canvas.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow, self.canvas)
        self.canvas.Bind(wx.EVT_MOTION, self.OnMouseMotion, self.canvas)
        
        # Bind keyboard events
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self)
        self.canvas.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self.canvas)
        
        # Keep track of which buttons are toggled
        # Since we are using bitmap buttons and they can't toggle
        # Also load all buttons' bitmaps and set appropriate ones
        ltlmopRoot = self.GetLtlmopRoot(sys.argv[0])
        if not ltlmopRoot:
            print "Cannot find LTLMoP root directory. Exiting..."
        self.toggleStates = {'vicon': False,
                             'square': False,
                             'poly': False,
                             'dim': False,
                             'feedback': False,
                             'addPoint': False,
                             'remPoint': False}
        self.buttonBitmaps = {'vicon': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\streamMarkersIcon.bmp"), wx.BITMAP_TYPE_ANY),
            'viconSel': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\streamMarkersIconSel.bmp"), wx.BITMAP_TYPE_ANY),
            'image': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\importImageIcon.bmp"), wx.BITMAP_TYPE_ANY),
            'square': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\rectIcon.bmp"), wx.BITMAP_TYPE_ANY),
            'squareSel': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\rectIconSel.bmp"), wx.BITMAP_TYPE_ANY),
            'poly': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\polyIcon.bmp"), wx.BITMAP_TYPE_ANY),
            'polySel': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\polyIconSel.bmp"), wx.BITMAP_TYPE_ANY),
            'dim': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\dimensionIcon.bmp"), wx.BITMAP_TYPE_ANY),
            'dimSel': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\dimensionIconSel.bmp"), wx.BITMAP_TYPE_ANY),
            'autobound': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\autoboundaryIcon.bmp"), wx.BITMAP_TYPE_ANY),
            'feedback': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\audioFeedbackIcon.bmp"), wx.BITMAP_TYPE_ANY),
            'feedbackSel': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\audioFeedbackIconSel.bmp"), wx.BITMAP_TYPE_ANY),
            'cal': wx.Bitmap(os.path.join(ltlmopRoot, \
            "images\\calibPointIcon.bmp"), wx.BITMAP_TYPE_ANY)}
        self.toggleVicon.SetBitmapLabel(self.buttonBitmaps['vicon'])
        self.buttonImage.SetBitmapLabel(self.buttonBitmaps['image'])
        self.toggleSquare.SetBitmapLabel(self.buttonBitmaps['square'])
        self.togglePoly.SetBitmapLabel(self.buttonBitmaps['poly'])
        self.toggleDim.SetBitmapLabel(self.buttonBitmaps['dim'])
        self.buttonAutobound.SetBitmapLabel(self.buttonBitmaps['autobound'])
        self.toggleFeedback.SetBitmapLabel(self.buttonBitmaps['feedback'])
        self.buttonCal.SetBitmapLabel(self.buttonBitmaps['cal'])
        
        # Determine mapping of the canvas panel to the field
        canvasLen = self.canvas.GetSize()       # Initial size of canvas (pixels)
        fieldRange = [(-3.0, 9.0), (-3.0, 3.0)] # Initial range of field (m)
                                                # [(xmin, xmax), (ymin, ymax)]
        # pose = pixPose * scale + offset
        # Note: y-pixels and y-pose have opposite directions
        xScale = (fieldRange[0][1] - fieldRange[0][0]) / float(canvasLen[0])
        xOffset = fieldRange[0][0]
        yScale = -(fieldRange[1][1] - fieldRange[1][0]) / float(canvasLen[1])
        yOffset = -fieldRange[1][0]
        self.canvasScale = Point(xScale, yScale)
        self.canvasOffset = Point(xOffset, yOffset)
        
        # Canvas display bitmap to speed up drawing
        self.canvasBitmap = wx.EmptyBitmap(self.canvas.GetSize().GetWidth(), \
            self.canvas.GetSize().GetHeight())
        
        # Region-related parameters
        self.regions = []                   # List of regions in the map
        self.adjacent = []                  # List of lists holding transition
                                            # edges between regions.
                                            # adjacent[i][j] contains a list of
                                            # indices of edges in region i that
                                            # connect to edges in region j.
                                            # adjacent[j][i] should contain a
                                            # list of the same length, but edge
                                            # indices are for region j.
                                            # adjacent[i][i] will be empty.
        self.polyVerts = []                 # Keeps points for region creation
                                            # and dimensioning
                                            # Region creation: [Point(x0,y0), ...]
                                            # Dimensioning: (idxRegion, idxVert)
        
        # Background-related parameters
        self.backgroundImage = None         # Background image data
        self.backgroundFile = ""            # Relative file path to the
                                            # background image
        self.backgroundPosition = None      # Position of left top corner and
                                            # dimensions of the background
                                            # image in absolute coordinates
                                            # [x, y, width, height]
        
        # Mouse-related parameters
        self.leftClickPt = Point(0.0, 0.0)  # Location of last left downclick
        self.rightClickPt = Point(0.0, 0.0) # Location of last right downclick
        self.justDoubleClicked = False      # Indicating double-click event
        self.tolerance = 5.0 * xScale       # Distance to consider as "same point" (m)
        # TODO: Make tolerance a parameter on pixels only
        #       Calculate "same point" with scale later
        self.selectedRegions = []           # List of currently selected regions
        
        # Set up for undo/redo capabilities
        # TODO: Disable self.menuUndo and self.menuRedo
        self.unredoBufLen = 50
        self.undoActions = collections.deque()
        self.redoActions = collections.deque()
        
        # Track whether map is accurate to file
        self.isSaved = True
        
        # Add paint event handler to draw on the canvas
        # TODO: Fix problems here
        #self.canvas.Bind(wx.EVT_PAINT, self.OnCanvasPaint)
        
        # Create Vicon listener
        self.markerPoses = []   # Marker positions to be drawn
        self.viconListener = vicon.ViconMarkerListener(self)
        self.dlgFeedback = None
        self.feedbackPoses = [] # Points to be drawn to give feedback for
                                # map building
        
        # Add close event handler to cleanup and possibly save before closing
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        
        # Display the GUI window and set up the map canvas
        if self.fileName and os.path.exists(self.fileName):
            self.ReadFile(self.fileName)
        self.Show()
        self.RedrawCanvas()
    
    def __set_properties(self):
        # begin wxGlade: regionEditor.__set_properties
        self.SetTitle("Region Editor")
        self.toggleVicon.SetMinSize((32, 32))
        self.toggleVicon.SetToolTipString("Stream markers")
        self.buttonImage.SetMinSize((32, 32))
        self.buttonImage.SetToolTipString("Import image (CTRL+I)")
        self.toggleSquare.SetMinSize((32, 32))
        self.toggleSquare.SetToolTipString("Rectangle (R)")
        self.togglePoly.SetMinSize((32, 32))
        self.togglePoly.SetToolTipString("Polygon (P)")
        self.toggleDim.SetMinSize((32, 32))
        self.toggleDim.SetToolTipString("Set length or scale image")
        self.buttonAutobound.SetMinSize((32, 32))
        self.buttonAutobound.SetToolTipString("Autoboundary")
        self.toggleFeedback.SetMinSize((32, 32))
        self.toggleFeedback.SetToolTipString("Audio feedback")
        self.buttonCal.SetMinSize((32, 32))
        self.buttonCal.SetToolTipString("Calibrate")
        self.canvas.SetMinSize((800, 400))
        self.canvas.SetBackgroundColour(wx.Colour(255, 255, 255))
        # end wxGlade
    
    def __do_layout(self):
        # begin wxGlade: regionEditor.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_13 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_13.Add(self.toggleVicon, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_13.Add(self.buttonImage, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_13.Add(self.toggleSquare, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_13.Add(self.togglePoly, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_13.Add(self.toggleDim, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_13.Add(self.buttonAutobound, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_13.Add(self.toggleFeedback, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_13.Add(self.buttonCal, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        self.topbar.SetSizer(sizer_13)
        sizer_1.Add(self.topbar, 0, wx.EXPAND, 0)
        sizer_1.Add(self.canvas, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        sizer_1.Fit(self)
        self.Layout()
        # end wxGlade
    
    def OnClose(self, event):
        """Perform cleanup tasks and close the application."""
        # Check if the closure can even be canceled and
        # if map is unsaved and ask if they want to save before closing
        if not event or event.CanVeto() and not self.isSaved:
            dlg = wx.MessageDialog(self,
                "Do you want to save changes before closing?",
                "Confirm Exit", wx.YES|wx.NO|wx.CANCEL|wx.ICON_QUESTION)
            result = dlg.ShowModal()
            dlg.Destroy()
            if result == wx.ID_YES:
                self.OnMenuSave(None)
            if result != wx.ID_CANCEL:
                self.viconListener.stop()
                # TODO: Check if vicon is indeed running, and put wait-notify
                #       in to close port before closing GUI
                self.Destroy()
        else:
            self.viconListener.stop()
            self.Destroy()
    
    def OnToggleVicon(self, event):  # wxGlade: regionEditor.<event_handler>
        # Change control values
        self.toggleStates['vicon'] = not self.toggleStates['vicon']
        self.menuMarkers.Check(self.toggleStates['vicon'])
        
        # Switch Vicon streaming on or off based on state of toggle button
        # Also switch button bitmap
        if self.toggleStates['vicon']:
            self.toggleVicon.SetBitmapLabel(self.buttonBitmaps['viconSel'])
            self.viconListener.start()
            
            # TODO: Add while loop to wait for data to come in
            #       If it times out print message
            #       If data comes in, zoom out to ensure all markers seen
        else:
            self.toggleVicon.SetBitmapLabel(self.buttonBitmaps['vicon'])
            self.viconListener.stop()
            # Reinitialize thread to enable restarting it
            self.viconListener = vicon.ViconMarkerListener(self)
    
    def OnButtonImage(self, event):  # wxGlade: regionEditor.<event_handler>
        self.OnMenuImageImport(None)
    
    def OnToggleSquare(self, event):  # wxGlade: regionEditor.<event_handler>
        self.toggleStates['square'] = not self.toggleStates['square']
        self.menuRect.Check(self.toggleStates['square'])
        if self.toggleStates['square']:
            self.toggleSquare.SetBitmapLabel(self.buttonBitmaps['squareSel'])
        else:
            self.toggleSquare.SetBitmapLabel(self.buttonBitmaps['square'])
        self.ResetMapToggles('square')
    
    def OnTogglePoly(self, event):  # wxGlade: regionEditor.<event_handler>
        self.toggleStates['poly'] = not self.toggleStates['poly']
        self.menuPoly.Check(self.toggleStates['poly'])
        if self.toggleStates['poly']:
            self.togglePoly.SetBitmapLabel(self.buttonBitmaps['polySel'])
        else:
            self.togglePoly.SetBitmapLabel(self.buttonBitmaps['poly'])
        self.ResetMapToggles('poly')
    
    def OnToggleDim(self, event):  # wxGlade: regionEditor.<event_handler>
        self.toggleStates['dim'] = not self.toggleStates['dim']
        if self.toggleStates['dim']:
            self.toggleDim.SetBitmapLabel(self.buttonBitmaps['dimSel'])
        else:
            self.toggleDim.SetBitmapLabel(self.buttonBitmaps['dim'])
        self.ResetMapToggles('dim')
    
    def OnButtonAutobound(self, event):  # wxGlade: regionEditor.<event_handler>
        self.AddToUndo()
        self.Autoboundary()
        self.RedrawCanvas()
    
    def OnToggleFeedback(self, event):  # wxGlade: regionEditor.<event_handler>
        self.toggleStates['feedback'] = not self.toggleStates['feedback']
        self.ResetMapToggles('feedback')
        if self.toggleStates['feedback']:
            self.toggleFeedback.SetBitmapLabel( \
                self.buttonBitmaps['feedbackSel'])
            self.dlgFeedback = FeedbackDialog(self)
            self.dlgFeedback.ShowModal()
        else:
            self.toggleFeedback.SetBitmapLabel(self.buttonBitmaps['feedback'])
            if self.dlgFeedback:
                self.dlgFeedback.OnClose(None)
    
    def OnButtonCal(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles()
        self.AddToUndo()
        calibGUI = calibrate.CalibrationFrame(None, -1, "")
        calibGUI.Initialize(parent=self)
    
    def OnMenuNew(self, event):  # wxGlade: regionEditor.<event_handler>
        self.AddToUndo()
        self.ResetMapToggles()
        self.regions = []
        self.adjacent = []
        self.backgroundImage = None
        self.backgroundFile = ""
        self.backgroundPosition = None
        self.RedrawCanvas()
    
    def OnMenuOpen(self, event):  # wxGlade: regionEditor.<event_handler>
        # Start up open dialog
        dialogOpen = wx.FileDialog(self, message="Open File", \
            defaultDir=sys.path[0], \
            defaultFile=self.fileName.split('\\').pop(), \
            wildcard="*.regions", style=wx.FD_OPEN)
        
        # Hit Open
        if dialogOpen.ShowModal() == wx.ID_OK:
            self.AddToUndo()
            filePath = dialogOpen.GetPath()
            if not os.path.exists(filePath) or not ('.regions' in filePath):
                return
            
            # Store the filename for saving
            self.fileName = filePath
            self.ReadFile(self.fileName)
            self.isSaved = True
            
            # Set double click flag in case file was selected that way
            self.justDoubleClicked = True
        
            # TODO: Rescale/pan map to bring full map into view
            self.RedrawCanvas()
        
        dialogOpen.Destroy()
    
    def OnMenuSave(self, event):  # wxGlade: regionEditor.<event_handler>
        """Save to file that has already been used."""
        # Filename known
        if self.fileName:
            # Bring up dialog box to ask about boundary if necessary
            if self.regions and not self.ExistBoundary():
                msg = "No boundary found. Automatically create rectangular boundary?"
                boundDialog = wx.MessageDialog(self, msg, style=wx.YES_NO|wx.CANCEL|\
                    wx.YES_DEFAULT|wx.ICON_EXCLAMATION|wx.STAY_ON_TOP)
                boundDiaResult = boundDialog.ShowModal()
                if boundDiaResult == wx.ID_YES:
                    self.Autoboundary()
                elif boundDiaResult == wx.ID_CANCEL:
                    return
            
            comments = {"FILE_HEADER":"This is a region definition file for " +
                                      "the LTLMoP toolkit.\nFormat details " +
                                      "are described at the beginning of " +
                                      "each section below.\n",
                        "Background": "Relative path of background image file",
                        "Regions": "Stored as JSON string",
                        "Transitions": "reg1name reg2name " + 
                                       "[(reg1face1idx reg2face1idx) " +
                                       "(reg1face2idx reg2face2idx) ...]",
                        "Obstacles": "Names of regions to treat as obstacles"}
            
            regionData = []
            for r in self.regions:
                d = r.getData()
                # Don't store the following attribute inside the regions
                del d['isObstacle']
                regionData.append(d)
            je = prettierJSONEncoder(indent=4)
            regionData = [je.encode(regionData)]
            
            transitionData = []
            for iReg1, destinations in enumerate(self.adjacent):
                # Note: Don't assume bi-directional transitions
                for iReg2, faces in enumerate(destinations):
                    if faces == []: continue    # No transitions so skip
                    
                    singleTrans = self.regions[iReg1].name + "\t" + \
                        self.regions[iReg2].name + "\t["
                    for face in faces:
                        singleTrans += "(" + str(face[0]) + "\t" + \
                            str(face[1]) + ")"
                    singleTrans += "]"
                    transitionData.append(singleTrans)
            
            obstacleRegions = [r.name for r in self.regions if r.isObstacle]
            
            data = {"Regions": regionData,
                    "Transitions": transitionData,
                    "Obstacles": obstacleRegions}
            
            if self.backgroundFile:
                backgroundData = [self.backgroundFile] + \
                    self.backgroundPosition
                data['Background'] = backgroundData

            fileMethods.writeToFile(self.fileName, data, comments)
            self.isSaved = True
        
        # No known filename
        else:
            self.OnMenuSaveAs(None)
    
    def OnMenuSaveAs(self, event):  # wxGlade: regionEditor.<event_handler>
        dialogSave = wx.FileDialog(self, message="Save File As", \
            defaultDir=sys.path[0], \
            defaultFile=self.fileName.split('\\').pop(), \
            wildcard="*.regions", style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
        # Hit Save and confirmed overwrite if necessary
        if dialogSave.ShowModal() == wx.ID_OK:
            self.fileName = dialogSave.GetPath()
            self.OnMenuSave(None)
        dialogSave.Destroy()

    def OnMenuExit(self, event):  # wxGlade: regionEditor.<event_handler>
        self.Close()

    def OnMenuUndo(self, event):  # wxGlade: regionEditor.<event_handler>
        """Revert the most recent undoable change."""
        # Currently drawing polygon
        # Note that this is not a redoable action by design
        if self.polyVerts:
            self.polyVerts = []
            self.RedrawCanvas()
        # Other undoable changes exist
        elif self.undoActions:
            # Save current state to redo
            newAction = Action(self.regions, self.adjacent)
            self.redoActions.append(newAction)
            
            # Undo action
            action = self.undoActions.pop()
            self.regions = action.stateRegions
            self.adjacent = action.stateAdjacent
            # TODO: if not self.undoActions: disable self.menuUndo
            # TODO: enable self.menuRedo
            self.selectedRegions = []
            self.RedrawCanvas()

    def OnMenuRedo(self, event):  # wxGlade: regionEditor.<event_handler>
        """Reapply most recently undone action."""
        # Redoable actions exist
        if self.redoActions:
            # Save current state to undo
            newAction = Action(self.regions, self.adjacent)
            self.undoActions.append(newAction)
            
            # Redo action
            action = self.redoActions.pop()
            self.regions = action.stateRegions
            self.adjacent = action.stateAdjacent
            # TODO: if not self.redoActions: disable self.menuRedo
            # TODO: enable self.menuUndo
            self.RedrawCanvas()
    
    def OnMenuSelectAll(self, event):  # wxGlade: regionEditor.<event_handler>
        self.selectedRegions = range(len(self.regions))
        self.RedrawVicon()

    def OnMenuEditRegion(self, event):  # wxGlade: regionEditor.<event_handler>
        # Edit most recently selected region
        if self.selectedRegions:
            iReg = self.selectedRegions.pop()
            self.selectedRegions = [iReg]
            self.EditRegion(iReg)

    def OnMenuDeleteRegion(self, event):  # wxGlade: regionEditor.<event_handler>
        self.AddToUndo()
        self.selectedRegions.sort()
        while self.selectedRegions:
            self.DeleteRegion(self.selectedRegions.pop())
    
    def OnMenuAutobound(self, event):  # wxGlade: regionEditor.<event_handler>
        self.AddToUndo()
        self.Autoboundary()
        self.RedrawCanvas()

    def OnMenuRect(self, event):  # wxGlade: regionEditor.<event_handler>
        self.OnToggleSquare(None)

    def OnMenuPoly(self, event):  # wxGlade: regionEditor.<event_handler>
        self.OnTogglePoly(None)

    def OnMenuAddPoint(self, event):  # wxGlade: regionEditor.<event_handler>
        self.toggleStates['addPoint'] = not self.toggleStates['addPoint']
        self.ResetMapToggles('addPoint')

    def OnMenuRemPoint(self, event):  # wxGlade: regionEditor.<event_handler>
        self.toggleStates['remPoint'] = not self.toggleStates['remPoint']
        self.ResetMapToggles('remPoint')

    def OnMenuMarkers(self, event):  # wxGlade: regionEditor.<event_handler>
        self.OnToggleVicon(None)

    def OnMenuMarkersClear(self, event):  # wxGlade: regionEditor.<event_handler>
        self.markerPoses = []
        self.RedrawVicon()

    def OnMenuImageImport(self, event):  # wxGlade: regionEditor.<event_handler>
        # Start up open dialog
        dialogOpen = wx.FileDialog(self, message="Import Background Image", \
            defaultDir=os.getcwd(), \
            defaultFile=os.path.basename(self.fileName), \
            style=wx.FD_OPEN)
        
        # Hit Open
        if dialogOpen.ShowModal() == wx.ID_OK:
            filePath = dialogOpen.GetPath()
            if not os.path.exists(filePath):
                return
            
            # Load image
            self.LoadBackgroundImage(filePath)
            self.isSaved = False
            
            # Set double click flag in case image was selected that way
            self.justDoubleClicked = True

    def OnMenuImageClear(self, event):  # wxGlade: regionEditor.<event_handler>
        """Erase the background image."""
        self.backgroundImage = None
        self.backgroundFile = ""
        self.backgroundPosition = None
        if -1 in self.selectedRegions:
            self.selectedRegions.remove(-1)
        self.RedrawCanvas()
    
    def OnMenuAbout(self, event):  # wxGlade: regionEditor.<event_handler>
        print "About not yet implemented"
        event.Skip()

    def OnMouseLeftDown(self, event):
        """Save the left click point so it can be used later."""
        self.leftClickPt, iReg, iPt, iEd, snapped = \
            self.SnapPoint(self.Pix2Map(event.GetPosition()))

    def OnMouseLeftUp(self, event):
        """Perform appropriate action based on current mode of operation."""
        # Get click position
        ptPix = event.GetPosition()
        pt, iReg, iPt, iEd, snapped = self.SnapPoint(self.Pix2Map(ptPix))
        
        # Has been handled by double-click event handler
        if self.justDoubleClicked:
            self.justDoubleClicked = False      # Reset flag
        
        # Creating a rectangular region
        elif self.toggleStates['square']:
            # Making the second corner of rectangle
            if self.polyVerts and pt.Dist(self.polyVerts[0]) > self.tolerance:
                pt1 = Point(self.polyVerts[0].x, pt.y)
                pt3 = Point(pt.x, self.polyVerts[0].y)
                self.polyVerts.append(pt1)
                self.polyVerts.append(pt)
                self.polyVerts.append(pt3)
                # Create a square between previous click and new click
                self.AddToUndo()
                self.CreateRegion()
            # Making the first corner of rectangle
            else:
                # Save point as first corner of square
                self.polyVerts.append(pt)

        # Creating a polygonal region
        elif self.toggleStates['poly']:
            # Closing the polygon to create a region
            if self.polyVerts and len(self.polyVerts) > 2 and \
                    pt == self.polyVerts[0]:
                self.AddToUndo()
                self.CreateRegion()
            # New point distinct from others
            elif not pt in self.polyVerts:
                self.polyVerts.append(pt)
                # Plot line between last two points
                if len(self.polyVerts) > 1:
                    x1pix, y1pix = self.Map2Pix(self.polyVerts[-2])
                    x2pix, y2pix = self.Map2Pix(pt)
                    dc = wx.WindowDC(self.canvas)
                    dc.DrawLine(x1pix, y1pix, x2pix, y2pix)

        # Dimensioning region edge or setting background image scale
        elif self.toggleStates['dim']:
            # First point on region to be clicked
            if (not self.polyVerts or isinstance(self.polyVerts, Point)) \
                    and iReg != -1 and iPt != -1:
                # Store region and point indeces
                self.polyVerts = (iReg, iPt)
            # Second unique point on region to be clicked
            elif iReg != -1 and iPt != -1 and (iReg, iPt) != self.polyVerts:
                # Request dimension
                currDist = self.regions[iReg].pointArray[iPt].Dist(self.regions[\
                    self.polyVerts[0]].pointArray[self.polyVerts[1]])
                dimDlg = wx.TextEntryDialog(self, \
                    "Current Length: %.3f" % currDist, caption='Dimension')
                result = dimDlg.ShowModal() == wx.ID_OK
                if not result:
                    # Clear first point
                    self.polyVerts = []
                else:
                    # Check for valid dimension (allow negative values)
                    try:
                        dim = float(dimDlg.GetValue())
                    except ValueError:
                        dimDlg.Destroy()
                        return
                    dimDlg.Destroy()

                    # Move second point along same line to specified distance
                    pt0 = self.regions[self.polyVerts[0]].pointArray[self.polyVerts[1]]
                    signx = 1.0
                    signy = 1.0
                    # Vertical line case
                    if pt0.x == pt.x:
                        if pt0.y > pt.y:
                            signy = -1.0
                        dx = 0.0
                        dy = signy * (dim - pt.Dist(pt0))
                    # Horizontal and normal line cases
                    else:
                        if pt0.x > pt.x:
                            signx = -1.0
                        if pt0.y > pt.y:
                            signy = -1.0
                        slope = (pt.y - pt0.y) / (pt.x - pt0.x)
                        dx = signx * (dim - pt.Dist(pt0)) / \
                            math.sqrt(1 + slope ** 2)
                        dy = slope * dx
                    self.AddToUndo()
                    self.regions[iReg].pointArray[iPt] += Point(dx, dy)
                    self.polyVerts = []
                    self.RecalcAdjacency(iReg)
                    self.RedrawCanvas()
            
            # Clicking on background image
            elif iReg == -1 and self.InsideBackgroundImage(pt):
                # First point on background image
                if not self.polyVerts or isinstance(self.polyVerts, tuple):
                    self.polyVerts = pt
                
                # Second unique point on background image
                elif pt.Dist(self.polyVerts) > self.tolerance:
                    # Request dimension
                    currDist = pt.Dist(self.polyVerts)
                    dimDlg = wx.TextEntryDialog(self, \
                        "Current Length: %.3f" % currDist, caption='Dimension')
                    if dimDlg.ShowModal() == wx.ID_OK:
                        # Check for valid dimension (disallow negative values)
                        try:
                            dim = float(dimDlg.GetValue())
                            if dim <= 0:
                                dimDlg.Destroy()
                                return
                        except ValueError:
                            dimDlg.Destroy()
                            return
                        dimDlg.Destroy()
                        
                        # Rescale image
                        self.backgroundPosition[1] = \
                            self.backgroundPosition[1] * dim / currDist
                        self.RedrawCanvas()
                    self.polyVerts = []
        
        # Adding a point to a region
        elif self.toggleStates['addPoint']:
            # Check that valid region edge is selected
            if iReg != -1 and iEd != -1:
                self.AddPointToRegion(pt, iReg, iEd)
        
        # Removing a point from a region
        elif self.toggleStates['remPoint']:
            # Check that valid region point is selected
            if iReg != -1 and iPt != -1:
                self.DeletePointFromRegion(iReg, iPt)
        
        # Dragging region(s) or image or vertices or panning map view
        elif pt.Dist(self.leftClickPt) > self.tolerance:
            self.leftClickPt, iReg, iPt, iEd, snapped = \
                self.SnapRegions(self.leftClickPt)
            iRegInner = self.InsideRegions(self.leftClickPt)
            
            # Dragging point(s)
            if iReg != -1 and iReg in self.selectedRegions and iPt != -1:
                # Change point position and check adjacencies
                self.AddToUndo()
                self.regions[iReg].pointArray[iPt].Set(pt.x, pt.y)
                self.RecalcAdjacency(iReg)
                self.RedrawCanvas()
            
            # Dragging region(s) and/or background image
            elif (iReg != -1 and iReg in self.selectedRegions) or \
                    (iRegInner != -1 and iRegInner in self.selectedRegions) \
                    or (-1 in self.selectedRegions and \
                    self.InsideBackgroundImage(self.leftClickPt)):
                # Change region(s) position and check adjacencies
                self.AddToUndo()
                delta = pt - self.leftClickPt
                for iRegSel in self.selectedRegions:
                    # Change region position
                    if iRegSel > -1:
                        for iPt in range(len(self.regions[iRegSel].pointArray)):
                            self.regions[iRegSel].pointArray[iPt] += delta
                    # Change background image position
                    else:
                        self.backgroundPosition[0] += delta
                for iRegSel in self.selectedRegions:
                    if iRegSel > -1:
                        self.RecalcAdjacency(iRegSel)
                self.RedrawCanvas()
        
            # Panning the map view
            else:
                downClickPix = self.Map2Pix(self.leftClickPt)
                self.canvasOffset = Point(self.canvasScale.x * \
                    (downClickPix[0] - ptPix[0]) + self.canvasOffset.x, \
                    self.canvasScale.y * (downClickPix[1] - ptPix[1]) + \
                    self.canvasOffset.y)
                self.RedrawCanvas()
        
        # Check if selecting or deselecting a region or background image
        else:
            if iReg != -1:
                iRegInner = iReg
            else:
                iRegInner = self.InsideRegions(pt)
            
            # Do something about that region selection
            # If selecting background image, put -1 as index in selectedRegions
            if iRegInner != -1 or self.InsideBackgroundImage(pt):
                # Selecting single region
                if not event.CmdDown():
                    self.selectedRegions = []
                    self.selectedRegions.append(iRegInner)
                
                # Deselecting a region
                elif iRegInner in self.selectedRegions:
                    self.selectedRegions.remove(iRegInner)
                
                # Adding a region to the selection
                else:
                    self.selectedRegions.append(iRegInner)
            
            # Clear all region selections
            else:
                self.selectedRegions = []
            self.RedrawVicon()
    
    def OnMouseLeftDClick(self, event):
        """Perform action based on current mode of operation."""
        
        # Set double-click flag so that next mouse-up is ignored
        self.justDoubleClicked = True
        
        # Creating a polygonal region
        if self.toggleStates['poly'] and self.polyVerts and \
                len(self.polyVerts) > 2:
            self.AddToUndo()
            self.CreateRegion()
        
        # Editing a region
        if self.selectedRegions and not self.toggleStates['square'] and \
                not self.toggleStates['poly'] and \
                not self.toggleStates['dim'] and \
                not self.toggleStates['addPoint'] and \
                not self.toggleStates['remPoint']:
            # Unset double-click flag since event does not propagate here
            self.justDoubleClicked = False
            
            # Edit clicked region if selected
            iReg = self.InsideRegions(self.Pix2Map(event.GetPosition()))
            if iReg != -1 and iReg in self.selectedRegions:
                self.selectedRegions = [iReg]
                self.EditRegion(iReg)
    
    def OnMouseRightDown(self, event):
        """Save the right click point so it can be used later."""
        self.rightClickPt, iReg, iPt, iEd, snapped = \
            self.SnapPoint(self.Pix2Map(event.GetPosition()))

    def OnMouseRightUp(self, event):
        # Check if in region creation or dimensioning mode
        if self.toggleStates['square'] or self.toggleStates['poly'] or \
                self.toggleStates['dim'] or self.toggleStates['addPoint'] or \
                self.toggleStates['remPoint']:
            self.ResetMapToggles()
        # TODO: else: open some kind of right-click menu at right-click point

    def OnMouseWheel(self, event):
        """Zoom on the map canvas."""
        ptPix = event.GetPosition()
        rot = event.GetWheelRotation()          # Usually +/- multiple of 120
        scaler = 0.75 ** (rot / 120)            # Zoom in to 75%
        # Keep mouse on the same point after zooming
        # pt = ptPix * scale + offset
        # pt = ptPix * scaleNew + offsetNew
        self.canvasOffset = Point(float(ptPix[0]) * self.canvasScale.x * \
            (1 - scaler) + self.canvasOffset.x, float(ptPix[1]) * \
            self.canvasScale.y * (1 - scaler) + self.canvasOffset.y)
        self.canvasScale = self.canvasScale * scaler
        self.RedrawCanvas()
    
    def OnMouseMotion(self, event):
        """Show appropriate display if mouse is in motion."""
        # Get position and information
        ptPix = event.GetPosition()
        pt, iReg, iPt, iEd, snapped = self.SnapPoint(self.Pix2Map(ptPix))
        
        # Set mouse cursor display and position as appropriate
        # Snapping to something
        if self.toggleStates['square'] or self.toggleStates['poly'] or \
                self.toggleStates['dim'] or self.toggleStates['addPoint'] or \
                self.toggleStates['remPoint']:
            if snapped:
                self.canvas.SetCursor(wx.StockCursor(wx.CURSOR_BULLSEYE))
            else:
                self.canvas.SetCursor(wx.StockCursor(wx.CURSOR_CROSS))
        else:
            self.canvas.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
            
        
        # Create device context for drawing
        dc = wx.WindowDC(self.canvas)
        dc = wx.GCDC(dc)
        self.canvas.PrepareDC(dc)
        dc.BeginDrawing()
        dc.SetBrush(wx.Brush(wx.WHITE, wx.TRANSPARENT))
        dc.SetPen(wx.Pen(wx.BLACK, 1, wx.SHORT_DASH))
        
        # Draw lines to or around the mouse if necessary
        # Drawing rectangle
        if self.toggleStates['square'] and self.polyVerts:
            self.RedrawVicon()
            ptPix0 = self.Map2Pix(self.polyVerts[-1])
            dc.DrawLine(ptPix0[0], ptPix0[1], ptPix[0], ptPix0[1])
            dc.DrawLine(ptPix[0], ptPix0[1], ptPix[0], ptPix[1])
            dc.DrawLine(ptPix[0], ptPix[1], ptPix0[0], ptPix[1])
            dc.DrawLine(ptPix0[0], ptPix[1], ptPix0[0], ptPix0[1])
        
        # Drawing a polygon
        elif self.toggleStates['poly'] and self.polyVerts:
            self.RedrawVicon()
            ptPix0 = self.Map2Pix(self.polyVerts[-1])
            dc.DrawLine(ptPix0[0], ptPix0[1], ptPix[0], ptPix[1])
        
        # Dimensioning region or image
        elif self.toggleStates['dim'] and self.polyVerts:
            self.RedrawVicon()
            # Dimensioning region
            if isinstance(self.polyVerts, tuple):
                ptPix0 = self.Map2Pix(self.regions[ \
                    self.polyVerts[0]].pointArray[self.polyVerts[1]])
            # Dimensioning background image
            else:
                ptPix0 = self.Map2Pix(self.polyVerts)
            dc.DrawLine(ptPix0[0], ptPix0[1], ptPix[0], ptPix[1])
        
        # Dragging region point, or region(s) and/or background image
        elif event.LeftIsDown() and self.selectedRegions:
            self.leftClickPt, iReg, iPt, iEd, snapped = \
                self.SnapRegions(self.leftClickPt)
            iRegInner = self.InsideRegions(self.leftClickPt)
            # Dragging point
            if iReg != -1 and iReg in self.selectedRegions and iPt != -1:
                self.RedrawVicon()
                # Draw walls that would connect to the new position
                nPts = len(self.regions[iReg].pointArray)
                ptPix0 = self.Map2Pix( \
                    self.regions[iReg].pointArray[(iPt - 1) % nPts])
                ptPix1 = self.Map2Pix( \
                    self.regions[iReg].pointArray[(iPt + 1) % nPts])
                dc.DrawLine(ptPix0[0], ptPix0[1], ptPix[0], ptPix[1])
                dc.DrawLine(ptPix1[0], ptPix1[1], ptPix[0], ptPix[1])
            
            # Dragging region(s) and/or background image
            elif (iReg != -1 and iReg in self.selectedRegions) or \
                    (iRegInner != -1 and iRegInner in self.selectedRegions) \
                    or (-1 in self.selectedRegions and \
                    self.InsideBackgroundImage(self.leftClickPt)):
                self.RedrawVicon()
                # Draw region(s)/image in new position(s)
                delta = pt - self.leftClickPt
                for iRegSel in self.selectedRegions:
                    # Region
                    if iRegSel > -1:
                        vertsPix = []
                        for vert in self.regions[iRegSel].pointArray:
                            vertPix = self.Map2Pix(vert + delta)
                            vertsPix.append(vertPix)
                        dc.DrawPolygon(vertsPix)
                    # Background image
                    else:
                        ptPix0 = self.Map2Pix(self.backgroundPosition[0] + \
                            delta)
                        ptPix1 = self.Map2Pix(self.backgroundPosition[0] + \
                            Point(self.backgroundPosition[1].x, \
                            -self.backgroundPosition[1].y) + delta)
                        dc.DrawLine(ptPix0[0], ptPix0[1], ptPix1[0], ptPix0[1])
                        dc.DrawLine(ptPix1[0], ptPix0[1], ptPix1[0], ptPix1[1])
                        dc.DrawLine(ptPix1[0], ptPix1[1], ptPix0[0], ptPix1[1])
                        dc.DrawLine(ptPix0[0], ptPix1[1], ptPix0[0], ptPix0[1])
        
        dc.EndDrawing()
    
    def OnKeyDown(self, event):
        keycode = event.GetKeyCode()
        
        # Backspace/Delete - Deletes selected regions
        if (keycode == wx.WXK_BACK or keycode == wx.WXK_DELETE) and \
                self.selectedRegions and not self.toggleStates['poly'] and \
                not self.toggleStates['square']:
            self.OnMenuDeleteRegion(None)
        
        # Backspace/Delete - Removes last set point during region creation
        elif (keycode == wx.WXK_BACK or keycode == wx.WXK_DELETE) and \
                self.polyVerts:
            if self.toggleStates['square'] or self.toggleStates['poly']:
                self.polyVerts.pop()
                self.RedrawVicon()
            elif self.toggleStates['dim']:
                self.polyVerts = []
        
        # Escape - Stops region/dimension creation
        elif keycode == wx.WXK_ESCAPE and (self.toggleStates['square'] or \
                self.toggleStates['poly'] or self.toggleStates['dim']):
            self.ResetMapToggles()
        
        # Ctrl+n - New
        elif event.CmdDown() and keycode == 78:
            self.OnMenuNew(None)
        
        # Ctrl+o - Open
        elif event.CmdDown() and keycode == 79:
            self.OnMenuOpen(None)
        
        # Ctrl+s - Save
        elif event.CmdDown() and keycode == 83:
            self.OnMenuSave(None)
        
        # Ctrl+q - Quit
        elif event.CmdDown() and keycode == 81:
            self.OnMenuExit(None)
        
        # Ctrl+z - Undo
        elif event.CmdDown() and keycode == 90:
            self.OnMenuUndo(None)
        
        # Ctrl+y - Redo
        elif event.CmdDown() and keycode == 89:
            self.OnMenuRedo(None)
        
        # Ctrl+a - Select All
        elif event.CmdDown() and keycode == 65:
            self.OnMenuSelectAll(None)
        
        # Ctrl+i - Import Background Image
        elif event.CmdDown() and keycode == 73:
            self.OnMenuImageImport(None)
        
        # Ctrl+e - Edit Region
        elif event.CmdDown() and keycode == 69:
            self.OnMenuEditRegion(None)
        
        # r - Rectangle Creation Mode
        elif keycode == 82:
            if not self.toggleStates['square']:
                self.OnToggleSquare(None)
        
        # p - Polygon Creation Mode
        elif keycode == 80:
            if not self.toggleStates['poly']:
                self.OnTogglePoly(None)
        
        # c - Create Point Mode
        elif keycode == 67:
            if not self.toggleStates['addPoint']:
                self.menuAddPoint.Check(True)
                self.OnMenuAddPoint(None)
        
        # d - Delete Point Mode
        elif keycode == 68:
            if not self.toggleStates['remPoint']:
                self.menuRemPoint.Check(True)
                self.OnMenuRemPoint(None)
        
        # Pass event on so other key combinations still work
        else:
            event.Skip()
    
    def OnEnterWindow(self, event):
        """Set the focus to the canvas to enable zooming."""
        self.canvas.SetFocus()
        self.RedrawVicon()
    
    def OnLeaveWindow(self, event):
        """Unset the focus from the canvas to disable zooming."""
        self.SetFocus()
    
    def OnCanvasPaint(self, event):
        """Redraw the contents of the canvas panel."""
        # Set up to draw
        dc = wx.PaintDC(self.canvas)
        
        # Redraw
        self.RedrawCanvas(dc)
        event.Skip()
    
    def RedrawCanvas(self, dc=None):
        """Redraw the contents of the canvas panel.
        Callable from outside or inside EVT_PAINT handler.
        
        dc - Device context object for drawing to canvas.
        """
        # Clear canvas
        self.canvas.ClearBackground()
        
        # Create bitmap to draw to
        width, height = self.canvas.GetSize()
        self.canvasBitmap = wx.EmptyBitmap(width, height)
        #self.canvasBitmap.UseAlpha()
        dc = wx.MemoryDC()
        dc.SelectObject(self.canvasBitmap)
        dc.BeginDrawing()
        border = [(0, 0), (width, 0), (width, height), (0, height)]
        dc.SetBrush(wx.Brush(wx.WHITE, wx.SOLID))
        dc.SetPen(wx.Pen(wx.WHITE, 1, wx.SOLID))
        dc.DrawPolygon(border)
        
        # Draw background image
        if self.backgroundImage:
            self.DrawBackgroundImage(dc=dc)
        
        # Draw axes and grid
        self.DrawGrid(dc=dc)
        
        # Redraw all regions
        for region in self.regions:
            self.DrawRegion(region, dc=dc)
        
        # Redraw all transition face indicators
        # Lower triangular matrix only
        for iReg in range(1, len(self.adjacent)):
            self.DrawAdjacencies(iReg, dc=dc)
        
        dc.EndDrawing()
        dc.SelectObject(wx.NullBitmap)
        
        # Draw the canvas bitmap with overlayed "temporary" drawings
        # such as markers, selection handles, partial regions
        self.RedrawVicon()
    
    def RedrawVicon(self):
        """Redraw the contents of the canvas panel quickly, only worrying about
        updating the marker positions, currently being created regions, and
        things connected to mouse-motion/mouse-hover.
        """
        # Create device context
        dc = wx.WindowDC(self.canvas)
        dc = wx.GCDC(dc)
        self.canvas.PrepareDC(dc)
        dc.BeginDrawing()
        
        # Draw canvas static images
        dc.DrawBitmap(self.canvasBitmap, 0, 0)
        
        # Redraw all markers
        self.DrawMarkers(self.markerPoses, dc=dc)
        
        # Redraw selection handles
        for iReg in self.selectedRegions:
            self.DrawSelectionHandle(iReg, dc=dc)
        
        # Redraw partial region
        if self.toggleStates['square'] or self.toggleStates['poly']:
            for iVert in range(len(self.polyVerts) - 1):
                ptPix1 = self.Map2Pix(self.polyVerts[iVert])
                ptPix2 = self.Map2Pix(self.polyVerts[iVert + 1])
                dc.DrawLine(ptPix1[0], ptPix1[1], ptPix2[0], ptPix2[1])
        
        # Redraw feedback points
        self.DrawFeedbackPoints(self.feedbackPoses, dc=dc)
        
        dc.EndDrawing()
    
    def DrawBackgroundImage(self, dc=None):
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        
        # Rescale image to make sense with current pan/zoom point
        xPix, yPix = self.Map2Pix(self.backgroundPosition[0])
        newWidth = int(self.backgroundPosition[1].x / self.canvasScale.x)
        newHeight = -int(self.backgroundPosition[1].y / self.canvasScale.y)
        if newHeight > 0 and newWidth > 0:
            image = self.backgroundImage.Scale(newWidth, newHeight)
            bitmap = wx.BitmapFromImage(image)
            
            # Draw image
            dc.DrawBitmap(bitmap, xPix, yPix, False)
        
        if isNewDC:
            dc.EndDrawing()
    
    def DrawGrid(self, dc=None):
        """Draw the axes and grid on the map canvas.

        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        
        # Draw background gridlines
        colLim, rowLim = self.canvas.GetSize()
        dc.SetPen(wx.Pen(wx.Colour(220, 220, 220), 1, wx.SOLID))
        start = self.Pix2Map((0, 0))
        finish = self.Pix2Map((colLim, rowLim))
        for x in range(int(start.x) - 1, int(finish.x) + 1):
            xPix = int((x - self.canvasOffset.x) / self.canvasScale.x)
            dc.DrawLine(xPix, 0, xPix, rowLim)
        for y in range(int(start.y) + 1, int(finish.y) - 1, -1):
            yPix = int((y - self.canvasOffset.y) / self.canvasScale.y)
            dc.DrawLine(0, yPix, colLim, yPix)
        
        # Draw axes
        dc.SetPen(wx.Pen(wx.Colour(0, 0, 0), 1, wx.SOLID))
        xPixOff = int(-self.canvasOffset.x / self.canvasScale.x)
        yPixOff = int(-self.canvasOffset.y / self.canvasScale.y)
        dc.DrawLine(0, yPixOff, colLim, yPixOff)
        dc.DrawLine(xPixOff, 0, xPixOff, rowLim)
        
        if isNewDC:
            dc.EndDrawing()

    def DrawMarkers(self, poses, dc=None):
        """Draw markers at specified global positions.

        poses - List of Points containing positions of markers in meters
                [(x, y), ...]
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        
        # Set up brush
        dc.SetBrush(wx.Brush(wx.Colour(255, 255, 255, 128), wx.SOLID))
        dc.SetPen(wx.Pen(wx.BLACK, 1, wx.SOLID))
        
        # Draw each marker
        for pose in poses:
            posePix = self.Map2Pix(pose)
            dc.DrawCircle(posePix[0], posePix[1], 4)
        
        if isNewDC:
            dc.EndDrawing()
    
    def DrawFeedbackPoints(self, poses, dc=None):
        """Draw points to assist with map building.
        
        poses - List of Points with points to draw in global coordinates.
        dc - Device context for drawing on the canvas.
        """
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        
        # Set up brush
        dc.SetBrush(wx.Brush(wx.Colour(255, 0, 0, 128), wx.SOLID))
        dc.SetPen(wx.Pen(wx.RED, 1, wx.SOLID))
        
        # Draw each marker
        for pose in poses:
            posePix = self.Map2Pix(pose)
            dc.DrawCircle(posePix[0], posePix[1], 8)
        
        if isNewDC:
            dc.EndDrawing()
    
    def DrawSelectionHandle(self, iReg, dc=None):
        """Draw markers indicating region(s) or background image that have 
        been selected by mouse.
        
        iReg - Index of region selected
               -1 indicates background image
        dc - Device context used for drawing on the canvas panel
        """
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        
        # Set up brush
        dc.SetPen(wx.Pen(wx.Colour(0, 0, 0), 1, wx.SOLID))
        
        # Region
        if iReg > -1:
            dc.SetBrush(wx.Brush(self.regions[iReg].color, wx.SOLID))
            for pt in self.regions[iReg].pointArray:
                ptPix = self.Map2Pix(pt)
                dc.DrawCircle(ptPix[0], ptPix[1], 5)
        # Background image
        else:
            xPix, yPix = self.Map2Pix(self.backgroundPosition[0])
            newWidth = int(self.backgroundPosition[1].x / self.canvasScale.x)
            newHeight = -int(self.backgroundPosition[1].y / self.canvasScale.y)
            if newWidth > 0 and newHeight > 0:
                dc.SetBrush(wx.Brush(wx.Colour(255, 255, 255), wx.SOLID))
                dc.DrawCircle(xPix, yPix, 5)
                dc.DrawCircle(xPix + newWidth, yPix, 5)
                dc.DrawCircle(xPix + newWidth, yPix + newHeight, 5)
                dc.DrawCircle(xPix, yPix + newHeight, 5)
        
        if isNewDC:
            dc.EndDrawing()

    def DrawRegion(self, region, dc=None):
        """Draw a single region.

        region - Instance of Region class, contains information about the region.
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        
        # Set brush to region color
        isBoundary = region.name.lower() == "boundary"
        if isBoundary:
            dc.SetBrush(wx.Brush(region.color, wx.TRANSPARENT))
            dc.SetPen(wx.Pen(wx.BLACK, 3, wx.SOLID))
        elif region.isObstacle:
            obstColor = wx.Colour(region.color.Red() / 10, \
                region.color.Green() / 10, region.color.Blue() / 10, 128)
            dc.SetBrush(wx.Brush(obstColor, wx.SOLID))
            dc.SetPen(wx.Pen(region.color, 1, wx.SOLID))
        else:
            innerColor = wx.Colour(region.color.Red(), region.color.Green(), \
                region.color.Blue(), 128)
            dc.SetBrush(wx.Brush(innerColor, wx.SOLID))
            dc.SetPen(wx.Pen(region.color, 1, wx.SOLID))
        dc.SetTextForeground(wx.BLACK)
        dc.SetBackgroundMode(wx.TRANSPARENT)
        dc.SetFont(wx.Font(12, wx.FONTFAMILY_SWISS, wx.NORMAL, wx.BOLD, False))
        
        # Set up label
        if region.isObstacle:
            labelText = "(%s)" % region.name
        else:
            labelText = region.name
        labelWidth, labelHeight = dc.GetTextExtent(labelText)
        
        # Draw region
        vertsPix = []
        xLabelPix = 0
        yLabelPix = 0
        for vert in region.pointArray:
            vertPix = self.Map2Pix(vert)
            vertsPix.append(vertPix)
            if not isBoundary:          # Put label in center
                xLabelPix += vertPix[0]
                yLabelPix += vertPix[1]
            else:                       # Put label in lower right corner
                xLabelPix = max(xLabelPix, vertPix[0])
                yLabelPix = max(yLabelPix, vertPix[1])
        dc.DrawPolygon(vertsPix)
        if isBoundary:
            xLabelPix = xLabelPix - labelWidth
        else:
            xLabelPix = xLabelPix / len(region.pointArray) - labelWidth / 2
            yLabelPix = yLabelPix / len(region.pointArray) - labelHeight / 2
        
        # Draw label
        if not isBoundary:
            dc.SetBrush(wx.Brush(region.color, wx.SOLID))
            dc.DrawRoundedRectangle(xLabelPix - 5, yLabelPix - 3, \
                labelWidth + 10, labelHeight + 6, 3)
        dc.DrawText(labelText, xLabelPix, yLabelPix)
        
        if isNewDC:
            dc.EndDrawing()
    
    def DrawAdjacencies(self, iReg, dc=None):
        """Draw lines to show adjacent region faces for one region.
        Uses self.regions and self.adjacent.
        
        iReg - Int, index of region of interest in self.regions.
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        if not dc:
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        dc.SetPen(wx.Pen(wx.Colour(255, 0, 0), 3, wx.SHORT_DASH))
        
        # Iterate adjacency matrix looking for shared faces for one region
        # Only need to iterate through lower triangle (not counting diagonal) 
        # since the matrix is "symmetric" and diagonal is just region to itself
        for jReg in range(iReg):
            for iREdge1, iREdge2 in self.adjacent[iReg][jReg]:
                # Not last edge in region
                pt1 = self.regions[iReg].pointArray[iREdge1]
                if iREdge1 < len(self.regions[iReg].pointArray) - 1:
                    pt2 = self.regions[iReg].pointArray[iREdge1 + 1]
                # Last edge in region
                else:
                    pt2 = self.regions[iReg].pointArray[0]
                pt1Pix = self.Map2Pix(pt1)
                pt2Pix = self.Map2Pix(pt2)
                dc.DrawLine(pt1Pix[0], pt1Pix[1], pt2Pix[0], pt2Pix[1])
    
    def LoadBackgroundImage(self, filePath):
        image = wx.Image(filePath)
        if not image.IsOk(): 
            wx.MessageBox("Cannot import image from file %s" % \
                (os.path.basename(filePath)), "Error",
                style = wx.OK | wx.ICON_ERROR, parent=self)
            return
        
        self.backgroundImage = image
        self.backgroundFile = os.path.relpath(filePath, \
            os.path.dirname(self.fileName))
        
        # If image position is unknown, just keep same image size
        if not self.backgroundPosition:
            leftTop = self.Pix2Map((0, 0))
            xExtent = float(image.GetWidth()) * self.canvasScale.x
            yExtent = -float(image.GetHeight()) * self.canvasScale.y
            self.backgroundPosition = [leftTop, Point(xExtent, yExtent)]
        
        # Redraw the map with the image
        self.RedrawCanvas()
    
    def ReadFile(self, filePath):
        """Extract data from the regions file specified.
        
        filePath - String specifying absolute file path.
        """
        # Pull all data from file into dictionary for parsing
        data = fileMethods.readFromFile(filePath)
        
        if data is None:
            return
        
        # Clear all current information
        self.regions = []
        self.adjacent = []
        self.backgroundImage = None
        self.backgroundFile = ""
        self.backgroundPosition = None
        
        # Load background image if it is defined
        if "Background" in data and data["Background"][0] != "None":
            backgroundPath = os.path.join(os.path.dirname(self.fileName), \
                data["Background"][0])
            if len(data["Background"]) == 5:
                self.backgroundPosition = \
                    [Point(float(data["Background"][1]), \
                    float(data["Background"][2])), \
                    Point(float(data["Background"][3]), \
                    float(data["Background"][4]))]
            self.LoadBackgroundImage(backgroundPath)
        
        # Set all region information from lines in file
        rdata = json.loads("\n".join(data["Regions"]))
        for rd in rdata:
            newRegion = Region()
            newRegion.setData(rd)
            self.regions.append(newRegion)

        # Make an empty adjacency matrix of size (nRegions) x (nRegions)
        self.adjacent = [[[] for j in range(len(self.regions))] \
            for i in range(len(self.regions))]
        
        # Assign region transitions
        # Each transition line format is this:
        # Region1Idx Region2Idx [(Reg1FaceIdx1 Reg2FaceIdx1) (Reg1FaceIdx2 Reg2FaceIdx2) ...]
        for tData in data["Transitions"]:
            tData = re.sub('[\[\]\(\)]', '', tData)
            tData = tData.split();      # Separate on any whitespace
            iReg1 = self.IndexOfRegionWithName(tData[0])
            iReg2 = self.IndexOfRegionWithName(tData[1])
            # All transitions between regions
            for i in range(2, len(tData), 2):
                iFaceReg1 = int(tData[i])
                iFaceReg2 = int(tData[i+1])
                self.adjacent[iReg1][iReg2].append((iFaceReg1, iFaceReg2))
                # Don't assume bidirectional transitions
                # Region file will specify both directions if bidirectional
                
        # Set "obstacleness" of regions
        if "Obstacles" in data:
            for regName in data["Obstacles"]:
                self.regions[self.indexOfRegionWithName( \
                    regName)].isObstacle = True
    
    def ResetMapToggles(self, toggleStay=None):
        """Clear all the other map-feature toggle buttons.
        Also resets region creation.

        toggleStay - String indicating toggle button to retain state.
            This must be a valid key to the dictionary toggleStates.
        """
        # Reset region creation and clear temporary lines
        self.polyVerts = []
        self.RedrawVicon()

        # Turn off all map-building toggles except specified one
        if self.toggleStates['square'] and toggleStay != 'square':
            self.toggleStates['square'] = False
            self.menuRect.Check(False)
            self.toggleSquare.SetBitmapLabel(self.buttonBitmaps['square'])
        if self.toggleStates['poly'] and toggleStay != 'poly':
            self.toggleStates['poly'] = False
            self.menuPoly.Check(False)
            self.togglePoly.SetBitmapLabel(self.buttonBitmaps['poly'])
        if self.toggleStates['dim'] and toggleStay != 'dim':
            self.toggleStates['dim'] = False
            self.menuMarkers.Check(False)
            self.toggleDim.SetBitmapLabel(self.buttonBitmaps['dim'])
        if self.toggleStates['addPoint'] and toggleStay != 'addPoint':
            self.toggleStates['addPoint'] = False
            self.menuAddPoint.Check(False)
        if self.toggleStates['remPoint'] and toggleStay != 'remPoint':
            self.toggleStates['remPoint'] = False
            self.menuRemPoint.Check(False)

    def CreateRegion(self):
        """Instantiate and create a region, perform cleanup actions.
        Use polyVerts to make the region and find transitions.
        """
        # Create region
        rName = 'r' + str(len(self.regions))
        region = Region(self.polyVerts, rName)
        self.regions.append(region)
        idxNewReg = len(self.regions) - 1
        # Add row and column to list of lists of lists representing adjacency
        self.adjacent.append([[] for col in xrange(len(self.adjacent))])
        for row in self.adjacent:
            row.append([])
        
        self.RecalcAdjacency(idxNewReg)
        
        # Cleanup and draw
        self.polyVerts = []
        self.RedrawCanvas()
    
    def DeleteRegion(self, iReg):
        """Removes region from regions list and adjacency list.
        
        iReg - Index of region to remove
        """
        # Remove region from tracking lists
        self.regions.pop(iReg)
        self.adjacent.pop(iReg)
        for jReg in range(len(self.regions)):
            self.adjacent[jReg].pop(iReg)
        
        # Redraw regions
        self.RedrawCanvas()

    def AddPointToRegion(self, pt, iReg, iEdge):
        """Add a vertex to the region.
        
        pt - Point object, location of new vertex in map coordinates
        iRegion - Int, index of region to modify
        iEdge - Int, index of the edge to replace with edges to and from pt
        """
        # Add point to other region
        self.regions[iReg].pointArray.insert(iEdge + 1, copy.copy(pt))
        # Update all transition edges
        # Loop through all regions
        for jReg in range(len(self.adjacent[iReg])):
            # All transitioning faces from region to others
            for kPair in range(len(self.adjacent[iReg][jReg])):
                thisRegFace, otherRegFace = self.adjacent[iReg][jReg][kPair]
                # Transition face has index greater than affected edge
                if thisRegFace > iEdge:
                    self.adjacent[iReg][jReg][kPair] = \
                        (thisRegFace + 1, otherRegFace)
                # Transition face is the affected edge
                elif thisRegFace == iEdge:
                    self.adjacent[iReg][jReg].\
                        append((thisRegFace + 1, otherRegFace))
            # All transitioning faces from other regions to this one
            for kPair in range(len(self.adjacent[jReg][iReg])):
                otherRegFace, thisRegFace = self.adjacent[jReg][iReg][kPair]
                # Transition face has index greater than affected edge
                if thisRegFace > iEdge:
                    self.adjacent[jReg][iReg][kPair] = \
                        (otherRegFace, thisRegFace + 1)
                # Transition face is the affected edge
                elif thisRegFace == iEdge:
                    self.adjacent[jReg][iReg].\
                        append((otherRegFace, thisRegFace + 1))
        
        # Only need to redraw Vicon since the only visible difference
        # should be if the region is currently selected (selection handle)
        self.RedrawVicon()
    
    def DeletePointFromRegion(self, iReg, iPt):
        """Remove a vertex from the region.
        
        iRegion - Int, index of region to modify
        iPt - Int, index of the point to remove
        """
        # Check if removal is possible
        if len(self.regions[iReg].pointArray) <= 3:
            print "WARNING: Cannot have fewer than 3 points in a region."
            print "         Point removal canceled."
            return
        
        # Remove point
        self.regions[iReg].pointArray.pop(iPt)
        
        # Update adjacencies
        self.RecalcAdjacency(iReg)
        
        # Redraw regions
        self.RedrawCanvas()
    
    def EditRegion(self, iReg):
        """Show the edit region dialog.
        Allow user to change name, color, and obstacleness of a region.
        
        iReg - Index of region to edit
        """
        # Create dialog
        regEdDia = RegionEditDialog(self, wx.ID_ANY, "Edit Region Information")
        
        # Set appropriate control values
        reg = self.regions[iReg]
        regEdDia.textName.SetValue(reg.name)
        regEdDia.colorPicker.SetColour(reg.color)
        regEdDia.chkbxObst.SetValue(reg.isObstacle)
        
        # Wait for user to close the dialog
        done = False
        while not done:
            answer = regEdDia.ShowModal()
            # User canceled
            if answer == wx.ID_CANCEL:
                regEdDia.Destroy()
                done = True
            # Same name or unique new name
            elif regEdDia.textName.GetValue() == reg.name or \
                    regEdDia.textName.GetValue() not in \
                    [r.name for r in self.regions]:
                self.AddToUndo()
                oldName = reg.name
                reg.name = regEdDia.textName.GetValue()
                reg.color = regEdDia.colorPicker.GetColour()
                reg.isObstacle = regEdDia.chkbxObst.GetValue()
                # Boundary region should have no adjacencies
                if reg.name.lower() == "boundary":
                    for iOthReg in range(len(self.regions)):
                        self.adjacent[iReg][iOthReg] = []
                        self.adjacent[iOthReg][iReg] = []
                # Recheck adjacencies if changed back from boundary
                elif oldName.lower() == "boundary":
                    self.RecalcAdjacency(iReg)
                regEdDia.Destroy()
                done = True
            # Non-unique name - needs to re-edit
            else:
                wx.MessageBox("Region with name \"%s\" already exists." % \
                    (regEdDia.textName.GetValue()), "Error", \
                    style = wx.OK | wx.ICON_ERROR)
        
        # Redraw the regions to ensure correct name/color
        self.RedrawCanvas()
    
    def RecalcAdjacency(self, iReg, iRegStart=0):
        """Recalculate the adjacent walls between the specified region and
        other regions. If walls or points are "close enough" to being colinear
        or colocated, they will be moved so that they overlap. The saved
        adjacency matrix will be updated accordingly.
        
        Can specify which region to start checking with so that the input
        region will not check against all regions. This is useful if entire map
        needs to be rechecked, it can be done so with:
        
            for iReg, reg in enumerate(self.regions):
                self.RecalcAdjacency(iReg, iRegStart=iReg)
        
        This will avoid redundant checking of regions. Note that the function
        will avoid checking against itself, so there is no reason to avoid
        calling it on itself. It will also not check against the boundary
        region.
        
        iReg - Index of region of interest
        iRegStart - Specifies to check iReg against self.regions[iRegStart:]
        """
        # Reset adjacency related to this region
        for iOthReg in range(len(self.regions)):
            self.adjacent[iReg][iOthReg] = []
            self.adjacent[iOthReg][iReg] = []
        
        # Pull region for easy access
        reg = self.regions[iReg]
        
        # Don't check for anything else if boundary
        if reg.name.lower() == "boundary":
            return
        
        # Keeps track of the colocation of vertices of this region with points
        # of other regions
        # List of lists of tuples
        # Outer list - len(vertColloc) == len(reg.pointArray)
        # Inner list - Contains collocation information for each region vertex
        # Tuple - Contains collocation information from vertex on this region
        #         to vertex on another region in the format:
        #         (iReg, iPt)
        vertsColloc = [[] for iPt in xrange(len(reg.pointArray))]
        
        # Check all other regions against this region
        for iOthReg in range(len(self.regions[iRegStart:])):
            # No need to check against self
            if iOthReg == iReg or \
                    self.regions[iOthReg].name.lower() == "boundary":
                continue
            
            for iOthPt, othPt in enumerate(self.regions[iOthReg].pointArray):
                pt, iPt, iEd, snapped = self.Snap1Region(reg, othPt)
                # Other region vertex snapped to wall of new region
                if iEd != -1:
                    # Add point to new region and update old transitions
                    self.AddPointToRegion(pt, iReg, iEd)
                    vertsColloc.append([])
                    # Don't bother tracking point connectivity here
                    # Recheck it in next loop so we can look at all regions
        
        # Check this region against others and create new vertices as necessary
        for iPt, pt in enumerate(reg.pointArray):
            snapResults = self.SnapRegions(pt, checkAll=True)
            # Process the "nearness" information
            for othPt, iOthReg, iOthPt, iOthEd in snapResults:
                # Ignore same region and boundary
                if iOthReg == iReg or \
                        self.regions[iOthReg].name.lower() == "boundary":
                    continue
                
                # Change region point location
                pt.Set(othPt.x, othPt.y)
                
                # Snapped to a point in the other region
                if iOthPt != -1:
                    vertsColloc[iPt].append((iOthReg, iOthPt))
                # Snapped to an edge of the other region
                elif iOthEd != -1:
                    self.AddPointToRegion(pt, iOthReg, iOthEd)
                    vertsColloc[iPt].append((iOthReg, iOthEd + 1))
        
        # Now look for adjacent edges and update transition matrix accordingly
        for iPt in range(len(reg.pointArray)):       # Start point of edge
            jPt = (iPt + 1) % len(reg.pointArray)    # End point of edge
            for iOthReg, iOthPt in vertsColloc[iPt]:
                jOthPt1 = (iOthPt - 1) % len(self.regions[iOthReg].pointArray)
                jOthPt2 = (iOthPt + 1) % len(self.regions[iOthReg].pointArray)
                # Check edge on other region prior to point
                if (iOthReg, jOthPt1) in vertsColloc[jPt]:
                    # Indicate transition from this region to other region
                    # from current this region side to other region side
                    # and reverse transition as well
                    self.adjacent[iReg][iOthReg].append((iPt, jOthPt1))
                    self.adjacent[iOthReg][iReg].append((jOthPt1, iPt))
                # Check edge on other region after point
                elif (iOthReg, jOthPt2) in vertsColloc[jPt]:
                    self.adjacent[iReg][iOthReg].append((iPt, iOthPt))
                    self.adjacent[iOthReg][iReg].append((iOthPt, iPt))
    
    def IndexOfRegionWithName(self, name):
        for i, region in enumerate(self.regions):
            if region.name.lower() == name.lower():
                return i
        print 'WARNING: Region "' + name + '" not found.'
        return -1
    
    def ExistBoundary(self):
        """Check if a boundary region has been defined."""
        found = False
        iReg = 0
        while not found and iReg < len(self.regions):
            found = self.regions[iReg].name.lower() == "boundary"
            iReg += 1
        
        return found
    
    def Autoboundary(self):
        """Automatically create region representing the boundary of the map."""
        if self.regions:
            minx, maxx, miny, maxy = self.GetMapBoundaries()
            
            # Create region
            points = [Point(minx, maxy), Point(maxx, maxy), \
                Point(maxx, miny), Point(minx, miny)]
            self.regions.append(Region(points, 'boundary'))
            
            # Add row and column to list of lists of lists that is adjacency
            # even though boundary won't use it
            self.adjacent.append([[] for col in xrange(len(self.adjacent))])
            for row in self.adjacent:
                row.append([])
        else:
            print "No regions defined, so no boundary created."
    
    def GetMapBoundaries(self):
        """Find the minimum and maximum coordinates of all regions on map.
        
        returns None if no regions defined
        returns (minX, maxX, minY, maxY) otherwise
        """
        # Check that there are regions first
        if self.regions:
            # Find extrema of map
            minx = float('inf')
            maxx = float('-inf')
            miny = float('inf')
            maxy = float('-inf')
            for reg in self.regions:
                for pt in reg.pointArray:
                    minx = min(minx, pt.x)
                    maxx = max(maxx, pt.x)
                    miny = min(miny, pt.y)
                    maxy = max(maxy, pt.y)
            
            return minx, maxx, miny, maxy
        else:
            return None

    def AddToUndo(self):
        """Add current state to the undo queue."""
        # Note that this is only called when doing a new action,
        # not when redoing since this clears the redo buffer
        action = Action(self.regions, self.adjacent)
        self.undoActions.append(action)
        while len(self.undoActions) > self.unredoBufLen:
            self.undoActions.popleft()
        self.redoActions.clear()
        self.isSaved = False
        # TODO: enable self.menuUndo

    def SnapPoint(self, pt):
        """Snap the point to any nearby Vicon or region point.

        pt - Point object, map coordinates of point
        returns - (snappedPt, idxRegion, idxRPoint, idxREdge, snapped)
            snappedPt - Point object, point after snapping
            idxRegion - int, index of region if snapped to region point/edge
                        if not snapped to region it will be -1
            idxRPoint - int, index of point in region.pointArray if snapped to point
                        if not snapped to point it will be -1
            idxREdge - int, index of side in region if snapped to edge
                       edge j is defined by region.pointArray[j:j+1]
                       if not snapped to edge it will be -1
            snapped - boolean, indicating if it snapped to anything, including
                      temporary regions and vicon markers
        """
        # TODO: Make menubar checkbox to disable/enable snapto
        # Check through all region points and edges first
        # (since Vicon points may be moving around)
        snapped = False
        pt, idxRegion, idxRPoint, idxREdge, snapped = \
            self.SnapRegions(pt, snapped=snapped)

        # Check points in current region creation
        # Only snap to vertices
        # Don't count this for iRegion or iRPoint
        pt, idxPolyPoint, snapped = self.SnapPoly(pt, snapped=snapped)

        # Check all Vicon points
        pt, idxMarker, snapped = self.SnapVicon(pt, snapped)

        # Only return region indices, since they are usually all that matter
        return pt, idxRegion, idxRPoint, idxREdge, snapped

    def SnapRegions(self, pt, checkAll=False, snapped=False):
        """Snap the point to any sufficiently "nearby" region vertex or wall.

        pt - Point object, map coordinates of point
        checkAll - Boolean, true if this function should check the point
                   against all regions, even if it has already snapped to one
        snapped - Boolean, true if point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns -
            If checkAll is true, then the return will be a list containing
            tuples in the format (snappedPt, idxRegion, idxRPoint, idxREdge),
            where each entry is as described below. If there is no snapping
            then the list will be empty.
            If checkAll is false, then a single tuple will be returned:
            (snappedPt, idxRegion, idxRPoint, idxREdge, snapped)
                snappedPt - Point object, point after snapping
                idxRegion - int, index of region if snapped to region point/edge
                            if not snapped to region it will be -1
                idxRPoint - int, index of point in region.pointArray if snapped to point
                            if not snapped to point it will be -1
                idxREdge - int, index of side in region if snapped to edge
                           edge j is defined by region.pointArray[j:j+1]
                           if not snapped to edge it will be -1
                snapped - Boolean, true if point has been snapped, false if not
                          Note that if input snapped is true, output will be true
                          even if the point did not snap to a region point or edge
        """
        # Initialize output
        if not checkAll:
            idxRegion = -1
            idxRPoint = -1
            idxREdge = -1
        else:
            output = []
        
        # Check through regions
        i = len(self.regions) - 1   # Region decrementer
        while (checkAll or not snapped) and i >= 0:
            pt, idxRPoint, idxREdge, snapped = \
                self.Snap1Region(self.regions[i], pt, \
                snapped=(not checkAll and snapped))
            if idxRPoint != -1 or idxREdge != -1:
                idxRegion = i
                if checkAll:
                    output.append((pt, idxRegion, idxRPoint, idxREdge))
            i -= 1
        
        if not checkAll:
            return pt, idxRegion, idxRPoint, idxREdge, snapped
        else:
            return output
    
    def Snap1Region(self, region, pt, snapped=False):
        """Snap the point to any sufficiently "nearby" region vertex or wall
        in the specified region.
        
        region - Region object, region of interest
        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxRPoint, idxREdge, snapped)
            snappedPt - Point object, point after snapping
            idxRPoint - int, index of point in region.pointArray if snapped to point
                        if not snapped to point it will be -1
            idxREdge - int, index of side in region if snapped to edge
                       edge j is defined by region.pointArray[j:j+1]
                       if not snapped to edge it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a region point or edge
        """
        idxRPoint = -1
        idxREdge = -1
        # Check first point
        chkPt = region.pointArray[0]
        if (not snapped) and pt.Dist(chkPt) < self.tolerance:
            pt = chkPt
            snapped = True
            idxRPoint = 0
        j = 1   # Region point incrementer
        while (not snapped) and j < len(region.pointArray):
            # Check next point
            chkPt = region.pointArray[j]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                snapped = True
                idxRPoint = j
            # Check edge between previous and just-checked point
            else:
                p0 = region.pointArray[j - 1]
                p1 = chkPt
                chkPt = self.ProjPtOnLine(pt, p0, p1)
                # Check that projected point is on finite line and close
                if pt.Dist(chkPt) < self.tolerance and \
                        chkPt.x <= max(p0.x, p1.x) and \
                        chkPt.x >= min(p0.x, p1.x) and \
                        chkPt.y <= max(p0.y, p1.y) and \
                        chkPt.y >= min(p0.y, p1.y):
                    pt = chkPt
                    snapped = True
                    idxREdge = j - 1
            j += 1
        # Check last edge
        if not snapped:
            p0 = region.pointArray[j - 1]
            p1 = region.pointArray[0]
            chkPt = self.ProjPtOnLine(pt, p0, p1)
            if pt.Dist(chkPt) < self.tolerance and \
                    chkPt.x <= max(p0.x, p1.x) and \
                    chkPt.x >= min(p0.x, p1.x) and \
                    chkPt.y <= max(p0.y, p1.y) and \
                    chkPt.y >= min(p0.y, p1.y):
                pt = chkPt
                snapped = True
                idxREdge = j - 1
        
        return copy.copy(pt), idxRPoint, idxREdge, snapped
    
    def SnapPoly(self, pt, snapped=False):
        """Snap the point to any vertex in the currently being created region
        if it is sufficiently "nearby".

        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxPoint, snapped)
            snappedPt - Point object, point after snapping
            idxPoint - int, index of point in self.polyVerts if snapped to it
                       if not snapped to point it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a polygon point
        """
        idxPoint = -1
        i = 0       # Misc point incrementer
        while (not snapped) and isinstance(self.polyVerts, list) and \
                i < len(self.polyVerts):
            chkPt = self.polyVerts[i]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                idxPoint = i
                snapped = True
            i += 1

        return copy.copy(pt), idxPoint, snapped

    def SnapVicon(self, pt, snapped):
        """Snap the point to any saved Vicon marker position if it is
        sufficiently "nearby".

        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxMarker, snapped)
            snappedPt - Point object, point after snapping
            idxMarker - int, index of point in self.markerPoses if snapped
                        if not snapped to point it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a Vicon point
        """
        idxMarker = -1
        i = 0       # Vicon point incrementer
        while (not snapped) and i < len(self.markerPoses):
            chkPt = self.markerPoses[i]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                idxMarker = i
                snapped = True
            i += 1

        return copy.copy(pt), idxMarker, snapped
    
    def InsideRegions(self, pt):
        """Find region containing point. Looks through regions on top first
        (those that were created later). Does not return for boundary region.
        
        pt - Point, point of interest
        returns - int, index of containing region, or -1 if none
        """
        iReg = -1
        i = len(self.regions) - 1
        while iReg == -1 and i >= 0:
            if self.regions[i].name.lower() != "boundary" and \
                    self.regions[i].PtInRegion(pt):
                iReg = i
            i -= 1
        
        return iReg
    
    def InsideBackgroundImage(self, pt):
        """Indicates if the given point was clicked inside the background image.
        
        Returns a boolean.
        """
        return self.backgroundImage and \
            pt.x > self.backgroundPosition[0].x and \
            pt.x < self.backgroundPosition[0].x + \
            self.backgroundPosition[1].x and \
            pt.y < self.backgroundPosition[0].y and \
            pt.y > self.backgroundPosition[0].y - \
            self.backgroundPosition[1].y
    
    def Map2Pix(self, pose):
        """Convert from map coordinates to pixel coordinates.

        pose - Point, map coordinates of point
        returns - Tuple, pixel coordinates in canvas panel (col, row)
        """
        col = int((pose.x - self.canvasOffset.x) / self.canvasScale.x)
        row = int((pose.y - self.canvasOffset.y) / self.canvasScale.y)
        return (col, row)

    def Pix2Map(self, pixPose):
        """Convert from pixel coordinates to map coordinates.

        pixPose - Tuple, pixel coordinates in canvas panel (col, row)
        returns - Point, map coordinates of point
        """
        x = float(pixPose[0]) * self.canvasScale.x + self.canvasOffset.x
        y = float(pixPose[1]) * self.canvasScale.y + self.canvasOffset.y
        return Point(x, y)

    def ProjPtOnLine(self, pt, p0, p1):
        """Find the projection of a point on an infinite line.

        pt - Point object, point to be projected.
        p1 - Point object, one endpoint of line.
        p2 - Point object, other endpoint of line.
        returns - Point object, projected point on line.
        """
        s = p1 - p0                     # Vector to project on (p0 is origin)
        v = pt - p0                     # Vector to point to project
        u = (v.Dot(s) / s.Dot(s)) * s   # Projected vector
        return p0 + u                   # Map back to global coordinates

    def GetLtlmopRoot(self, thisFile):
        """Return a string of the absolute path to the project root directory.
        
        thisFile - String with the path to this file, should be found using
                   sys.argv[0]
        """
        p = os.path.abspath(thisFile)
        t = ""
        while t != "src":
            (p, t) = os.path.split(p)
            if p == "":
                return None

        return os.path.join(p, "src")
    # end of class RegionEditor


class FeedbackDialog(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: FeedbackDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.buttonPrev = wx.Button(self, -1, "Previous")
        self.buttonNext = wx.Button(self, -1, "Next")
        self.chkbxIterate = wx.CheckBox(self, -1, "Automatically iterate points when marker is in position")
        self.radioboxOption = wx.RadioBox(self, -1, "Feedback Method", choices=["Speech", "Beeping"], majorDimension=1, style=wx.RA_SPECIFY_ROWS)
        self.chkbxMute = wx.CheckBox(self, -1, "Mute")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.OnButtonPrev, self.buttonPrev)
        self.Bind(wx.EVT_BUTTON, self.OnButtonNext, self.buttonNext)
        # end wxGlade

        # Add close event handler to cleanup before closing
        self.Bind(wx.EVT_CLOSE, self.OnClose)

        # Save reference to RegionEditor GUI
        if len(args) > 0 and isinstance(args[0], regionEditor):
            self.parent = args[0]
            if not self.parent.regions:
                print "ERROR: No regions defined prior to requesting feedback."
                if self.parent.toggleStates['feedback']:
                    self.parent.OnToggleFeedback(None)
                self.Destroy()
                return
        else:
            print "ERROR: FeedbackDialog will not work without " + \
                "reference to RegionEditor GUI as first parameter."
            self.Destroy()
            return
        
        # Keep track of Vicon settings before opening this
        hadMarkers = len(self.parent.markerPoses) > 0
        wasStreaming = self.parent.toggleStates['vicon']
        wasTracking = self.parent.viconListener.trackMarkers
        self.oldSettings = (hadMarkers, wasStreaming, wasTracking)

        # Track current point
        self.chkbxIterate.SetValue(True)
        self.currReg = 0
        self.currPt = 0

        # Start audio feedback thread
        if self.parent:
            self.feedbackThread = AudioFeedbackThread(self, self.parent)
            self.feedbackThread.start()

    def __set_properties(self):
        # begin wxGlade: FeedbackDialog.__set_properties
        self.SetTitle("Marker Placement")
        self.buttonPrev.SetMinSize((50, 50))
        self.buttonNext.SetMinSize((50, 50))
        self.chkbxIterate.SetValue(1)
        self.radioboxOption.SetSelection(0)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: FeedbackDialog.__do_layout
        sizerOuter = wx.BoxSizer(wx.VERTICAL)
        sizerOptions = wx.BoxSizer(wx.VERTICAL)
        sizerButtons = wx.BoxSizer(wx.HORIZONTAL)
        sizerButtons.Add(self.buttonPrev, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerButtons.Add(self.buttonNext, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerOuter.Add(sizerButtons, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizerOptions.Add(self.chkbxIterate, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerOptions.Add(self.radioboxOption, 0, wx.ALL | wx.EXPAND, 5)
        sizerOptions.Add(self.chkbxMute, 0, wx.ALL, 5)
        sizerOuter.Add(sizerOptions, 1, wx.EXPAND, 0)
        self.SetSizer(sizerOuter)
        sizerOuter.Fit(self)
        self.Layout()
        # end wxGlade

    def OnClose(self, event):
        """Perform cleanup tasks and close the feedback dialog."""
        self.feedbackThread.stop()
        if self.parent.toggleStates['feedback']:
            self.parent.OnToggleFeedback(None)
        # TODO: Add wait/notify to make sure thread ended
        
        # Reset to old settings
        hadMarkers, wasStreaming, wasTracking = self.oldSettings
        self.parent.viconListener.trackMarkers = wasTracking
        if not wasStreaming and self.parent.toggleStates['vicon']:
            self.parent.OnToggleVicon(None)
            # TODO: Change checkbox too
            if not hadMarkers:
                time.sleep(1)   # Wait for Vicon listener to close
                self.parent.markerPoses = []
        self.parent.RedrawVicon()
        
        self.Destroy()

    def OnButtonPrev(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        """Move back to previous point."""
        # Not first point in region
        if self.currPt > 0:
            self.currPt -= 1
        # First point in region
        else:
            # Not first region
            if self.currReg > 0:
                self.currReg -= 1
            # First region
            else:
                self.currReg = len(self.parent.regions) - 1
            self.currPt = len(self.parent.regions[self.currReg].pointArray) - 1

    def OnButtonNext(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        """Move on to next point."""
        # Not last point in region
        if self.currPt < len(self.parent.regions[self.currReg].pointArray) - 1:
            self.currPt += 1
        # Last point in region
        else:
            # Not last region
            if self.currReg < len(self.parent.regions) - 1:
                self.currReg += 1
            # Last region
            else:
                self.currReg = 0
            self.currPt = 0
# end of class FeedbackDialog


class RegionEditDialog(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: RegionEditDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.label_1 = wx.StaticText(self, -1, "Name: ")
        self.textName = wx.TextCtrl(self, -1, "")
        self.label_2 = wx.StaticText(self, -1, "Color: ")
        self.colorPicker = wx.ColourPickerCtrl(self, -1)
        self.chkbxObst = wx.CheckBox(self, -1, "Treat as obstacle")
        self.buttonOk = wx.Button(self, wx.ID_OK, "OK")
        self.buttonCancel = wx.Button(self, wx.ID_CANCEL, "Cancel")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: RegionEditDialog.__set_properties
        self.SetTitle("Edit Region")
        self.colorPicker.SetMinSize((40, 40))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: RegionEditDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_4 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_3.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_3.Add(self.textName, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_2.Add(sizer_3, 1, wx.EXPAND, 0)
        sizer_4.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_4.Add(self.colorPicker, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_2.Add(sizer_4, 1, wx.EXPAND, 0)
        sizer_2.Add(self.chkbxObst, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_5.Add(self.buttonOk, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_5.Add(self.buttonCancel, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 8)
        sizer_2.Add(sizer_5, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade
# end of class RegionEditDialog


class Action:
    def __init__(self, regions, adjacent):
        """Create an object that represents an (un/re)doable action.
        Deep copies are used to avoid retaining same state when state changes.
        
        regions - Regions array before the action was taken.
        adjacent - Adjacencies matrix before the action was taken.
        """
        self.stateRegions = copy.deepcopy(regions)
        self.stateAdjacent = copy.deepcopy(adjacent)
# end of class Action


class AudioFeedbackThread(threading.Thread):
    def __init__(self, feedbackDialog, regEditor):
        """Create audio feedback for marker placement.

        fbDia - Dialog box that specifies the point of interest.
        regEd - RegionEditor GUI that gets Vicon information.
        """
        super(AudioFeedbackThread, self).__init__()

        # Save other objects
        self.fbDia = feedbackDialog
        self.regEd = regEditor
        
        # Start Vicon streaming if necessary
        if not self.regEd.toggleStates['vicon']:
            self.regEd.OnToggleVicon(None)
            # TODO: Also check menu item
        
        # Tell marker listener to track the moving markers
        self.regEd.viconListener.trackMarkers = True
        
        # Non-audio parameters
        self.close = threading.Event()
        self.tolerance = 0.10   # Close-enough distance (m)
        self.maxDist = 2.5      # Points must be within this to react (m)

        # Audio parameters for beeping
        # Chosen for audibility at distance
        # TODO: Make modifiable by configuration file
        minFreq = 600           # Lowest frequency played (Hz)
        maxFreq = 7000          # Highest frequency played (Hz)
        updateFreq = 2.0        # Frequency of possible sound change (Hz)
        self.duration = int(1000.0 / updateFreq)
        
        # Audio parameters for text-to-speech
        self.engine = pyttsx.init()
        self.engine.setProperty('rate', 120)
        self.engine.setProperty('volume', 1.0)
        self.speechFormat = "X %.1f, Y %.1f"
        self.speechPause = 1.0  # Pause between voice commands

        # Calculate the line representing the distance-frequency mapping
        self.freqSlope = (minFreq - maxFreq) / (self.maxDist - self.tolerance)
        self.freqIntercept = maxFreq - self.tolerance * self.freqSlope

    def run(self):
        """Play sound based on distance of moving marker to goal point."""
        self.close.clear()
        while not self.close.isSet():
            soundOption = self.fbDia.radioboxOption.GetSelection()
            if self.regEd.regions and not self.fbDia.chkbxMute.GetValue():
                # Get distance from closest marker to point of interest
                intPt = self.regEd.regions[self.fbDia.currReg].\
                    pointArray[self.fbDia.currPt]
                minStatDistToPt = 2.0 * self.maxDist
                for statPt in self.regEd.markerPoses:
                    if not statPt in self.regEd.viconListener.movingPoses:
                        minStatDistToPt = min(minStatDistToPt, intPt.Dist(statPt))

                # Get distance from closest moving point to point of interest
                minDistToPt = 2.0 * self.maxDist
                minPtIdx = -1
                for iPt, movPt in \
                        enumerate(self.regEd.viconListener.movingPoses):
                    dist = intPt.Dist(movPt)
                    if dist < minDistToPt:
                        minDistToPt = dist
                        minPtIdx = iPt

                # Plot moving point and goal point
                poses = [intPt]
                if minPtIdx > -1 and minPtIdx < \
                        len(self.regEd.viconListener.movingPoses):
                    poses.append( \
                        self.regEd.viconListener.movingPoses[minPtIdx])
                self.regEd.feedbackPoses = poses
                # Assume that this will be plotted with next Vicon redraw

                # Close-enough
                if minDistToPt < self.tolerance or \
                        minStatDistToPt < self.tolerance:
                    # Marker is settled
                    if minStatDistToPt < self.tolerance or self.regEd.\
                            viconListener.movingTimeout[minPtIdx] < \
                            self.regEd.viconListener.movMaxTime:
                        # Play "success" sound to indicate done with point
                        if soundOption:
                            time.sleep(0.2)
                            winsound.Beep(600, 200)
                            winsound.Beep(1200, 200)
                            winsound.Beep(1800, 200)
                            time.sleep(0.2)
                        else:
                            self.engine.say("Success, next")
                            self.engine.runAndWait()
                            time.sleep(self.speechPause)
                        # Switch to next point of interest if checked
                        if self.fbDia.chkbxIterate.GetValue():
                            self.fbDia.OnButtonNext(None)
                            # TODO: Check if all points are in correct spots
                            #       and stop if done

                    # Marker not yet settled
                    else:
                        # Play "good" sound to signal "stop moving marker"
                        if soundOption:
                            time.sleep(0.2)
                            winsound.Beep(1200, 200)
                            winsound.Beep(1200, 200)
                            time.sleep(0.2)
                        else:
                            self.engine.say("Stop there")
                            self.engine.runAndWait()
                            time.sleep(self.speechPause)
                
                # Still within distance of effect
                elif minDistToPt < self.maxDist:
                    if soundOption:
                        freq = int(self.freqIntercept + self.freqSlope * \
                            minDistToPt)
                        winsound.Beep(freq, self.duration)
                    else:
                        diffPt = intPt - self.regEd.viconListener.\
                            movingPoses[minPtIdx]
                        self.engine.say(self.speechFormat % \
                            (diffPt.x, diffPt.y))
                        self.engine.runAndWait()
                        time.sleep(self.speechPause)
    
    def stop(self):
        """Signal for the thread to end."""
        self.engine.stop()
        self.close.set()
        
        # Clear poses for drawing
        self.regEd.feedbackPoses = []


if __name__ == "__main__":
    app = wx.PySimpleApp(0)
    wx.InitAllImageHandlers()
    if len(sys.argv) > 1:
        regEd = regionEditor(None, -1, sys.argv[1])
    else:
        regEd = regionEditor(None, -1)
    app.SetTopWindow(regEd)
    app.MainLoop()
